<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script>
      ; (function () {
        var src = '//cdn.jsdelivr.net/npm/eruda';
        if (!/eruda=true/.test(window.location) && localStorage.getItem('active-eruda') != 'true') return;
        document.write('<scr' + 'ipt src="' + src + '"></scr' + 'ipt>');
        document.write('<scr' + 'ipt>eruda.init();</scr' + 'ipt>');
      })();
    </script>
    
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
        }
      }
    </script>

    <link rel="stylesheet" href="./assets/base.css">

    <title>Interaction Line between objects</title>
  </head>

  <body>

    <script type="module">
      import * as THREE from 'three';
      import { ARButton } from 'three/addons/webxr/ARButton.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      // Lighting
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;

      document.body.appendChild(renderer.domElement);
      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      const controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // Reticle
      const reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial()
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);


      const cube = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32).translate(0, 0.1, 0);
      const mesh1 = new THREE.Mesh(cube, new THREE.MeshPhongMaterial({ color: 0x9c48b9 }));
      const mesh2 = new THREE.Mesh(cube, new THREE.MeshPhongMaterial({ color: 0x398e93 }));
      const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
        mesh1.position,
        mesh2.position,
      ]), new THREE.LineBasicMaterial({
        color: 0x0000ff
      }));
      mesh1.visible = false;
      mesh2.visible = false;
      line.visible = false;
      scene.add(mesh1);
      scene.add(mesh2);

      let switcher = true;

      function onSelect() {
        if (reticle.visible) {


          if (switcher) {
            mesh2.visible = true;
            reticle.matrix.decompose(mesh2.position, mesh2.quaternion, mesh2.scale);
            switcher = false;
          } else {
            mesh1.visible = true;
            reticle.matrix.decompose(mesh1.position, mesh1.quaternion, mesh1.scale);
            switcher = true;
          }

          if (mesh1.visible && mesh2.visible) {

            console.log('hit', switcher, line);
            line.visible = true;
            line.geometry.setFromPoints([
              mesh1.position,
              mesh2.position,
            ]);
          }
        }
      }

      // Animation
      let hitTestSource = null;
      let hitTestSourceRequested = false;

      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();

          if (hitTestSourceRequested === false) {
            session.requestReferenceSpace('viewer').then(function (referenceSpace) {
              session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                 hitTestSource = source;
              });
            });

            session.addEventListener('end', function () {
              hitTestSourceRequested = false;
              hitTestSource = null;
            });

            hitTestSourceRequested = true;
          }

          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);

            if (hitTestResults.length) {
              const hit = hitTestResults[0];

              reticle.visible = true;
              reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);

            } else {
              reticle.visible = false;
            }
          }
        }

        renderer.render(scene, camera);
      });


    </script>
  </body>

</html>